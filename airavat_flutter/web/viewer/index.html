<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Digital Twin (SMPL)</title>
    <style>
      html, body { height: 100%; }
      body {
        margin: 0;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: linear-gradient(135deg, #ffffff 0%, #fff7cc 40%, #d9fbe6 100%);
      }
      /* Hide built-in UI; controls come from Flutter */
      #ui { display: none; }
      #ui h4 { margin: 0 0 8px 0; font-size: 14px; }
      #ui .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; }
      #ui label { font-size: 12px; width: 64px; color: #333; }
      #ui select, #ui input[type=number], #ui input[type=range] { font-size: 12px; }
      #status { position: absolute; top: 10px; right: 10px; z-index: 10; padding: 10px; background: rgba(0,0,0,0.75); color: #fff; border-radius: 8px; font-size: 12px; min-width: 200px; }
      .btn { background: #0ea5e9; border: none; color: #fff; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
      .btn:disabled { background: #9ca3af; cursor: default; }
      
      @keyframes pulse {
        0% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.7; transform: scale(1.1); }
        100% { opacity: 1; transform: scale(1); }
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
  <div id="ui">
    <h4>SMPL Controls</h4>
    <div class="row">
      <label>Model</label>
      <select id="model">
        <option value="neutral">Neutral</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>
    </div>
    <div class="row">
      <label>Height</label>
      <input id="height" type="range" min="140" max="200" step="1" value="170"/>
      <input id="heightNum" type="number" min="140" max="200" step="1" value="170" style="width:60px"/>
      <span>cm</span>
    </div>
    <div class="row">
      <label>Weight</label>
      <input id="weight" type="range" min="45" max="120" step="1" value="70"/>
      <input id="weightNum" type="number" min="45" max="120" step="1" value="70" style="width:60px"/>
      <span>kg</span>
    </div>
    <div class="row">
      <label>Beta1</label>
      <input id="beta1" type="range" min="0" max="1" step="0.01" value="0.4"/>
      <input id="beta1Num" type="number" min="0" max="1" step="0.01" value="0.4" style="width:60px"/>
    </div>
    <div class="row">
      <button id="apply" class="btn">Apply</button>
    </div>
  </div>
  <div id="status">Initializing...</div>
  
  <!-- Biomarker overlay container -->
  <div id="biomarker-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10;">
    <!-- Biomarker widgets will be added here -->
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const SMPL_API_BASE = 'https://airavat-backend-10892877764.us-central1.run.app';
    const SMPL_ASSETS_BASE_URL = 'https://storage.googleapis.com/mira-smpl-assets/models';

    let scene, camera, renderer, controls;
    let currentMesh = null;
    let biomarkerOverlays = new Map();
    let currentPatientId = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    const modelSel = document.getElementById('model');
    const heightR = document.getElementById('height');
    const heightN = document.getElementById('heightNum');
    const weightR = document.getElementById('weight');
    const weightN = document.getElementById('weightNum');
    const beta1R = document.getElementById('beta1');
    const beta1N = document.getElementById('beta1Num');

    init();
    fetchAndLoad();
    const applyBtn = document.getElementById('apply');

    heightR?.addEventListener('input', () => heightN.value = heightR.value);
    heightN?.addEventListener('input', () => heightR.value = heightN.value);
    weightR?.addEventListener('input', () => weightN.value = weightR.value);
    weightN?.addEventListener('input', () => weightR.value = weightN.value);
    beta1R?.addEventListener('input', () => beta1N.value = beta1R.value);
    beta1N?.addEventListener('input', () => beta1R.value = beta1N.value);

    modelSel?.addEventListener('change', fetchAndLoad);
    applyBtn?.addEventListener('click', fetchAndLoad);

    window.addEventListener('message', async (evt) => {
      const data = evt?.data || {};
      if (data?.type === 'smpl:update') {
        const p = data.payload || {};
        if (p.gender) modelSel.value = p.gender;
        if (p.height) heightR.value = heightN.value = p.height;
        if (p.weight) weightR.value = weightN.value = p.weight;
        if (typeof p.beta1 === 'number') beta1R.value = beta1N.value = p.beta1;
        await fetchAndLoad();
      } else if (data?.type === 'loadPatient') {
        currentPatientId = data.patientId;
        const profile = data.profile || {};
        if (profile.height) heightR.value = heightN.value = profile.height;
        if (profile.weight) weightR.value = weightN.value = profile.weight;
        if (profile.gender) modelSel.value = profile.gender;
        await fetchAndLoad();
        await loadPatientBiomarkers(data.patientId);
      } else if (data?.type === 'updateBiomarkers') {
        await addBiomarkerOverlays(data.biomarkers);
      }
    });

    async function fetchAndLoad() {
      const model = modelSel?.value || 'neutral';
      const height = Number(heightR?.value || 170);
      const weight = Number(weightR?.value || 70);
      const beta1 = Number(beta1R?.value || 0.4);
      setStatus('Loading SMPL...');
      
      try {
        // Try to get signed URL from backend first with proper CORS handling
        const params = new URLSearchParams({
          patient_id: 'viewer',
          height: String(height),
          weight: String(weight),
          gender: model,
          model: model,
          beta1: String(beta1)
        });
        
        // First try with /api rewrite path (Firebase Hosting)
        let response = null;
        let backendUrl = `/api/smpl/generate?${params.toString()}`;
        
        try {
          response = await fetch(backendUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.asset_url) {
              await loadGLB(data.asset_url, data.parameters);
              setStatus(`Loaded ${model}.glb via Firebase rewrite`);
              return;
            }
          }
        } catch (rewriteError) {
          console.log('Firebase rewrite failed, trying direct Cloud Run:', rewriteError);
        }
        
        // Fallback to direct Cloud Run URL
        try {
          backendUrl = `${SMPL_API_BASE}/smpl/generate?${params.toString()}`;
          response = await fetch(backendUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.asset_url) {
              await loadGLB(data.asset_url, data.parameters);
              setStatus(`Loaded ${model}.glb via direct backend`);
              return;
            }
          }
        } catch (directError) {
          console.log('Direct Cloud Run failed:', directError);
        }
        
        // Fallback to direct GCS access
        const glbUrl = `${SMPL_ASSETS_BASE_URL}/${model}.glb`;
        const parameters = {
          height_cm: height,
          weight_kg: weight,
          gender: model,
          beta1: beta1,
          bmi: height > 0 ? Math.round(weight / ((height / 100.0) ** 2) * 10) / 10 : null
        };
        
        try {
          await loadGLB(glbUrl, parameters);
          setStatus(`Loaded ${model}.glb from GCS fallback`);
          return;
        } catch (gcsError) {
          console.log('GCS access failed:', gcsError);
        }
        
        // Final fallback to placeholder
        await loadPlaceholder(parameters);
        setStatus('Loaded placeholder (all sources failed)');
        
      } catch (e) {
        console.error('Error loading SMPL:', e);
        try {
          const parameters = {
            height_cm: height,
            weight_kg: weight,
            gender: model,
            beta1: beta1
          };
          await loadPlaceholder(parameters);
          setStatus('Loaded placeholder (error occurred)');
        } catch (fallbackError) {
          console.error('Fallback also failed:', fallbackError);
          setStatus('Error loading SMPL');
        }
      }
    }

    async function loadGLB(url, parameters) {
      const loader = new GLTFLoader();
      const gltf = await loader.loadAsync(url);
      if (currentMesh) scene.remove(currentMesh);
      const root = gltf.scene || gltf.scenes?.[0];
      if (!root) throw new Error('No scene in GLB');

      const h = parameters?.height_cm ?? 170;
      const w = parameters?.weight_kg ?? 70;
      const overall = 2.2; // slightly taller overall scale for vertical framing
      const hScale = h / 170.0;
      const wScale = w / 70.0;
      root.scale.set(overall * wScale, overall * hScale, overall * wScale);

      const beta1 = typeof parameters?.beta1 === 'number' ? parameters.beta1 : undefined;
      if (typeof beta1 === 'number') {
        root.traverse(obj => {
          if (obj.morphTargetInfluences) {
            obj.morphTargetInfluences[0] = Math.max(0, Math.min(1, beta1));
          }
        });
      }

      scene.add(root);
      currentMesh = root;
      
      // Force matrix update for proper bounds calculation
      root.updateMatrixWorld(true);
      
      console.log('✅ SMPL model loaded, ready for biomarkers');
    }

    async function loadPlaceholder(parameters) {
      if (currentMesh) scene.remove(currentMesh);
      const group = new THREE.Group();
      const h = parameters?.height_cm ?? 170;
      const w = parameters?.weight_kg ?? 70;
      const hScale = h / 170.0;
      const wScale = w / 70.0;
      const overall = 2.2;
      const torso = new THREE.Mesh(
        new THREE.CylinderGeometry(0.28 * wScale * overall, 0.23 * wScale * overall, 0.9 * hScale * overall, 32),
        new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 30 })
      );
      torso.position.y = 1.2 * hScale * overall;
      group.add(torso);
      scene.add(group);
      currentMesh = group;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = null;
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2.2, 5.2); // higher Y, a bit closer Z for vertical framing
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const amb = new THREE.AmbientLight(0xffffff, 0.95);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(5, 10, 7.5);
      scene.add(dir);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2.0;
      controls.maxDistance = 10.0; // tighter zoom range
      controls.maxPolarAngle = Math.PI * 0.55; // limit tilt for portrait view

      // Setup biomarker interaction
      setupBiomarkerInteraction();

      window.addEventListener('resize', onResize);
      (function animate(){ 
        requestAnimationFrame(animate); 
        controls.update(); 
        renderer.render(scene, camera); 
      })();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text;
    }

    // === BIOMARKER OVERLAY FUNCTIONS ===
    
    async function loadPatientBiomarkers(patientId) {
      try {
        setStatus(`Loading biomarkers for ${patientId}...`);
        
        // Wait for SMPL model to be fully loaded and positioned
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Try to get biomarkers from digital twin first
        const twinResponse = await fetch(`${SMPL_API_BASE}/digital_twin/${patientId}`);
        if (twinResponse.ok) {
          const twinData = await twinResponse.json();
          if (twinData.biomarkers) {
            await addBiomarkerOverlays(twinData.biomarkers);
            setStatus(`Loaded ${Object.keys(twinData.biomarkers).length} biomarkers`);
            return;
          }
        }
        
        // Fallback: try agent biomarkers endpoint
        const bioResponse = await fetch(`${SMPL_API_BASE}/agent/patient/${patientId}/biomarkers`);
        if (bioResponse.ok) {
          const bioData = await bioResponse.json();
          if (bioData.status === 'success' && bioData.biomarkers) {
            await addBiomarkerOverlays(bioData.biomarkers);
            setStatus(`Loaded ${Object.keys(bioData.biomarkers).length} biomarkers`);
            return;
          }
        }
        
        // Use sample biomarkers for demo
        const sampleBiomarkers = {
          glucose: 95,
          cholesterol: 180,
          heart_rate: 72,
          hemoglobin: 14.5,
          blood_pressure_systolic: 120,
          oxygen_saturation: 98
        };
        await addBiomarkerOverlays(sampleBiomarkers);
        setStatus('Loaded sample biomarkers (demo)');
        
      } catch (error) {
        console.error('Error loading biomarkers:', error);
        setStatus('Error loading biomarkers');
      }
    }

    async function addBiomarkerOverlays(biomarkers) {
      if (!currentMesh || !biomarkers) return;
      
      // Clear existing HTML overlays
      const container = document.getElementById('biomarker-container');
      if (container) {
        container.innerHTML = '';
      }
      biomarkerOverlays.clear();
      
      // Create HTML biomarker widgets positioned over the 3D canvas
      Object.entries(biomarkers).forEach(([name, value], index) => {
        const status = calculateBiomarkerStatus(name, value);
        const isLeft = index % 2 === 0;
        
        // Create HTML biomarker widget
        const biomarkerWidget = createBiomarkerHTMLWidget(name, value, status, isLeft, index);
        container.appendChild(biomarkerWidget);
        biomarkerOverlays.set(name, biomarkerWidget);
      });
      
      console.log(`✅ Added ${Object.keys(biomarkers).length} HTML biomarker overlays`);
    }

    function createBiomarkerHTMLWidget(name, value, status, isLeft, index) {
      const widget = document.createElement('div');
      const displayName = name.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
      const unit = getBiomarkerUnit(name);
      
      // Position widget on left or right side of screen
      const verticalPosition = 20 + (index * 80); // Stack vertically
      const horizontalPosition = isLeft ? '20px' : 'auto';
      const horizontalPositionRight = isLeft ? 'auto' : '20px';
      
      // Status colors
      const statusColors = {
        'normal': '#00ff88',
        'warning': '#ffaa00', 
        'high': '#ff4444',
        'low': '#0088ff',
        'critical': '#ff0000'
      };
      const statusColor = statusColors[status] || '#00ff88';
      
      widget.style.cssText = `
        position: absolute;
        top: ${verticalPosition}px;
        left: ${horizontalPosition};
        right: ${horizontalPositionRight};
        width: 200px;
        background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(20,20,20,0.9));
        border: 2px solid ${statusColor};
        border-radius: 12px;
        padding: 12px;
        color: white;
        font-family: -apple-system, BlinkMacSystemFont, Arial;
        pointer-events: auto;
        cursor: pointer;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;
      
      widget.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <div style="
            width: 12px; 
            height: 12px; 
            background: ${statusColor}; 
            border-radius: 50%; 
            box-shadow: 0 0 10px ${statusColor};
            animation: pulse 2s infinite;
          "></div>
          <div style="flex: 1;">
            <div style="font-size: 14px; font-weight: 600; margin-bottom: 4px;">
              ${displayName}
            </div>
            <div style="font-size: 18px; font-weight: bold; color: ${statusColor};">
              ${value} ${unit}
            </div>
            <div style="font-size: 11px; opacity: 0.8; text-transform: uppercase; font-weight: 600;">
              ${status}
            </div>
          </div>
        </div>
      `;
      
      // Add hover effects
      widget.addEventListener('mouseenter', () => {
        widget.style.transform = 'scale(1.05)';
        widget.style.boxShadow = `0 12px 40px rgba(0,0,0,0.4), 0 0 20px ${statusColor}40`;
      });
      
      widget.addEventListener('mouseleave', () => {
        widget.style.transform = 'scale(1)';
        widget.style.boxShadow = '0 8px 32px rgba(0,0,0,0.3)';
      });
      
      // Add click handler
      widget.addEventListener('click', () => {
        window.parent.postMessage({
          type: 'biomarkerSelected',
          biomarker: name,
          value: value,
          status: status
        }, '*');
        console.log(`🎯 Selected biomarker: ${name}`);
      });
      
      widget.userData = { biomarker: name, value: value, status: status };
      
      return widget;
    }

    // Remove old 3D positioning - now using HTML overlays

    function calculateBiomarkerStatus(biomarkerName, value) {
      const ranges = {
        'glucose': [70, 100],
        'cholesterol': [120, 200],
        'hemoglobin': [12, 16],
        'heart_rate': [60, 100],
        'blood_pressure_systolic': [90, 140],
        'blood_pressure_diastolic': [60, 90],
        'oxygen_saturation': [95, 100]
      };
      
      const range = ranges[biomarkerName];
      if (!range) return 'normal';
      
      const [min, max] = range;
      if (value < min) return 'low';
      if (value > max) return 'high';
      if (value > max * 0.9) return 'warning';
      return 'normal';
    }

    function getBiomarkerColor(status) {
      const colors = {
        'normal': 0x00ff00,   // Green
        'warning': 0xffaa00,  // Orange
        'high': 0xff4400,     // Red-orange
        'low': 0x0088ff,      // Blue
        'critical': 0xff0000  // Red
      };
      return colors[status] || 0x00ff00;
    }

    // Remove old 3D label creation - now using HTML widgets

    function getBiomarkerUnit(biomarkerName) {
      const units = {
        'glucose': 'mg/dL',
        'cholesterol': 'mg/dL',
        'hemoglobin': 'g/dL',
        'heart_rate': 'bpm',
        'blood_pressure_systolic': 'mmHg',
        'blood_pressure_diastolic': 'mmHg',
        'temperature': '°F',
        'oxygen_saturation': '%',
        'bmi': 'kg/m²'
      };
      return units[biomarkerName] || '';
    }

    // HTML biomarkers handle their own click events - no 3D interaction needed
    function setupBiomarkerInteraction() {
      // No longer needed - HTML widgets handle their own events
    }

    // HTML biomarkers don't need 3D animation - CSS handles the pulsing

    window.loadSMPLAvatar = async function(patientId, height, weight, gender, opts={}) {
      currentPatientId = patientId;
      if (gender) modelSel.value = gender;
      if (height) heightR.value = heightN.value = height;
      if (weight) weightR.value = weightN.value = weight;
      if (opts.beta1 !== undefined) beta1R.value = beta1N.value = opts.beta1;
      await fetchAndLoad();
      if (patientId) await loadPatientBiomarkers(patientId);
    }
    
    window.updateSMPLParameters = async function(height, weight, gender, opts={}) {
      if (gender) modelSel.value = gender;
      if (height) heightR.value = heightN.value = height;
      if (weight) weightR.value = weightN.value = weight;
      if (opts.beta1 !== undefined) beta1R.value = beta1N.value = opts.beta1;
      await fetchAndLoad();
      if (currentPatientId) await loadPatientBiomarkers(currentPatientId);
    }
    
    window.getSMPLHealth = async function() {
      // Check if GCS assets are accessible
      try {
        const testUrl = `${SMPL_ASSETS_BASE_URL}/male.glb`;
        const response = await fetch(testUrl, { method: 'HEAD' });
        return response.ok ? { status: 'ok', assets_available: true } : { status: 'error', assets_available: false };
      } catch (e) {
        return { status: 'error', assets_available: false, error: e.message };
      }
    }
  </script>
</body>
</html>
