<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Digital Twin (SMPL)</title>
    <style>
      html, body { height: 100%; }
      body {
        margin: 0;
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: linear-gradient(135deg, #ffffff 0%, #fff7cc 40%, #d9fbe6 100%);
      }
      /* Hide built-in UI; controls come from Flutter */
      #ui { display: none; }
      #ui h4 { margin: 0 0 8px 0; font-size: 14px; }
      #ui .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; }
      #ui label { font-size: 12px; width: 64px; color: #333; }
      #ui select, #ui input[type=number], #ui input[type=range] { font-size: 12px; }
      #status { position: absolute; top: 10px; right: 10px; z-index: 10; padding: 10px; background: rgba(0,0,0,0.75); color: #fff; border-radius: 8px; font-size: 12px; min-width: 200px; }
      .btn { background: #0ea5e9; border: none; color: #fff; padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; }
      .btn:disabled { background: #9ca3af; cursor: default; }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.172.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.172.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
  <div id="ui">
    <h4>SMPL Controls</h4>
    <div class="row">
      <label>Model</label>
      <select id="model">
        <option value="neutral">Neutral</option>
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>
    </div>
    <div class="row">
      <label>Height</label>
      <input id="height" type="range" min="140" max="200" step="1" value="170"/>
      <input id="heightNum" type="number" min="140" max="200" step="1" value="170" style="width:60px"/>
      <span>cm</span>
    </div>
    <div class="row">
      <label>Weight</label>
      <input id="weight" type="range" min="45" max="120" step="1" value="70"/>
      <input id="weightNum" type="number" min="45" max="120" step="1" value="70" style="width:60px"/>
      <span>kg</span>
    </div>
    <div class="row">
      <label>Beta1</label>
      <input id="beta1" type="range" min="0" max="1" step="0.01" value="0.4"/>
      <input id="beta1Num" type="number" min="0" max="1" step="0.01" value="0.4" style="width:60px"/>
    </div>
    <div class="row">
      <button id="apply" class="btn">Apply</button>
    </div>
  </div>
  <div id="status">Initializing...</div>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const SMPL_API_BASE = 'https://airavat-backend-10892877764.us-central1.run.app';
    const SMPL_ASSETS_BASE_URL = 'https://storage.googleapis.com/mira-smpl-assets/models';

    let scene, camera, renderer, controls;
    let currentMesh = null;
    let biomarkerOverlays = new Map();
    let currentPatientId = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    const modelSel = document.getElementById('model');
    const heightR = document.getElementById('height');
    const heightN = document.getElementById('heightNum');
    const weightR = document.getElementById('weight');
    const weightN = document.getElementById('weightNum');
    const beta1R = document.getElementById('beta1');
    const beta1N = document.getElementById('beta1Num');

    init();
    fetchAndLoad();
    const applyBtn = document.getElementById('apply');

    heightR?.addEventListener('input', () => heightN.value = heightR.value);
    heightN?.addEventListener('input', () => heightR.value = heightN.value);
    weightR?.addEventListener('input', () => weightN.value = weightR.value);
    weightN?.addEventListener('input', () => weightR.value = weightN.value);
    beta1R?.addEventListener('input', () => beta1N.value = beta1R.value);
    beta1N?.addEventListener('input', () => beta1R.value = beta1N.value);

    modelSel?.addEventListener('change', fetchAndLoad);
    applyBtn?.addEventListener('click', fetchAndLoad);

    window.addEventListener('message', async (evt) => {
      const data = evt?.data || {};
      if (data?.type === 'smpl:update') {
        const p = data.payload || {};
        if (p.gender) modelSel.value = p.gender;
        if (p.height) heightR.value = heightN.value = p.height;
        if (p.weight) weightR.value = weightN.value = p.weight;
        if (typeof p.beta1 === 'number') beta1R.value = beta1N.value = p.beta1;
        await fetchAndLoad();
      } else if (data?.type === 'loadPatient') {
        currentPatientId = data.patientId;
        const profile = data.profile || {};
        if (profile.height) heightR.value = heightN.value = profile.height;
        if (profile.weight) weightR.value = weightN.value = profile.weight;
        if (profile.gender) modelSel.value = profile.gender;
        await fetchAndLoad();
        await loadPatientBiomarkers(data.patientId);
      } else if (data?.type === 'updateBiomarkers') {
        await addBiomarkerOverlays(data.biomarkers);
      }
    });

    async function fetchAndLoad() {
      const model = modelSel?.value || 'neutral';
      const height = Number(heightR?.value || 170);
      const weight = Number(weightR?.value || 70);
      const beta1 = Number(beta1R?.value || 0.4);
      setStatus('Loading SMPL...');
      
      try {
        // Try to get signed URL from backend first with proper CORS handling
        const params = new URLSearchParams({
          patient_id: 'viewer',
          height: String(height),
          weight: String(weight),
          gender: model,
          model: model,
          beta1: String(beta1)
        });
        
        // First try with /api rewrite path (Firebase Hosting)
        let response = null;
        let backendUrl = `/api/smpl/generate?${params.toString()}`;
        
        try {
          response = await fetch(backendUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.asset_url) {
              await loadGLB(data.asset_url, data.parameters);
              setStatus(`Loaded ${model}.glb via Firebase rewrite`);
              return;
            }
          }
        } catch (rewriteError) {
          console.log('Firebase rewrite failed, trying direct Cloud Run:', rewriteError);
        }
        
        // Fallback to direct Cloud Run URL
        try {
          backendUrl = `${SMPL_API_BASE}/smpl/generate?${params.toString()}`;
          response = await fetch(backendUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json',
            },
            mode: 'cors',
            credentials: 'omit'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.asset_url) {
              await loadGLB(data.asset_url, data.parameters);
              setStatus(`Loaded ${model}.glb via direct backend`);
              return;
            }
          }
        } catch (directError) {
          console.log('Direct Cloud Run failed:', directError);
        }
        
        // Fallback to direct GCS access
        const glbUrl = `${SMPL_ASSETS_BASE_URL}/${model}.glb`;
        const parameters = {
          height_cm: height,
          weight_kg: weight,
          gender: model,
          beta1: beta1,
          bmi: height > 0 ? Math.round(weight / ((height / 100.0) ** 2) * 10) / 10 : null
        };
        
        try {
          await loadGLB(glbUrl, parameters);
          setStatus(`Loaded ${model}.glb from GCS fallback`);
          return;
        } catch (gcsError) {
          console.log('GCS access failed:', gcsError);
        }
        
        // Final fallback to placeholder
        await loadPlaceholder(parameters);
        setStatus('Loaded placeholder (all sources failed)');
        
      } catch (e) {
        console.error('Error loading SMPL:', e);
        try {
          const parameters = {
            height_cm: height,
            weight_kg: weight,
            gender: model,
            beta1: beta1
          };
          await loadPlaceholder(parameters);
          setStatus('Loaded placeholder (error occurred)');
        } catch (fallbackError) {
          console.error('Fallback also failed:', fallbackError);
          setStatus('Error loading SMPL');
        }
      }
    }

    async function loadGLB(url, parameters) {
      const loader = new GLTFLoader();
      const gltf = await loader.loadAsync(url);
      if (currentMesh) scene.remove(currentMesh);
      const root = gltf.scene || gltf.scenes?.[0];
      if (!root) throw new Error('No scene in GLB');

      const h = parameters?.height_cm ?? 170;
      const w = parameters?.weight_kg ?? 70;
      const overall = 2.2; // slightly taller overall scale for vertical framing
      const hScale = h / 170.0;
      const wScale = w / 70.0;
      root.scale.set(overall * wScale, overall * hScale, overall * wScale);

      const beta1 = typeof parameters?.beta1 === 'number' ? parameters.beta1 : undefined;
      if (typeof beta1 === 'number') {
        root.traverse(obj => {
          if (obj.morphTargetInfluences) {
            obj.morphTargetInfluences[0] = Math.max(0, Math.min(1, beta1));
          }
        });
      }

      scene.add(root);
      currentMesh = root;
    }

    async function loadPlaceholder(parameters) {
      if (currentMesh) scene.remove(currentMesh);
      const group = new THREE.Group();
      const h = parameters?.height_cm ?? 170;
      const w = parameters?.weight_kg ?? 70;
      const hScale = h / 170.0;
      const wScale = w / 70.0;
      const overall = 2.2;
      const torso = new THREE.Mesh(
        new THREE.CylinderGeometry(0.28 * wScale * overall, 0.23 * wScale * overall, 0.9 * hScale * overall, 32),
        new THREE.MeshPhongMaterial({ color: 0x4a90e2, shininess: 30 })
      );
      torso.position.y = 1.2 * hScale * overall;
      group.add(torso);
      scene.add(group);
      currentMesh = group;
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = null;
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 2.2, 5.2); // higher Y, a bit closer Z for vertical framing
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const amb = new THREE.AmbientLight(0xffffff, 0.95);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xffffff, 1.2);
      dir.position.set(5, 10, 7.5);
      scene.add(dir);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2.0;
      controls.maxDistance = 10.0; // tighter zoom range
      controls.maxPolarAngle = Math.PI * 0.55; // limit tilt for portrait view

      // Setup biomarker interaction
      setupBiomarkerInteraction();

      window.addEventListener('resize', onResize);
      (function animate(){ 
        requestAnimationFrame(animate); 
        controls.update(); 
        animateBiomarkers(); // Add biomarker animations
        renderer.render(scene, camera); 
      })();
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text;
    }

    // === BIOMARKER OVERLAY FUNCTIONS ===
    
    async function loadPatientBiomarkers(patientId) {
      try {
        setStatus(`Loading biomarkers for ${patientId}...`);
        
        // Try to get biomarkers from digital twin first
        const twinResponse = await fetch(`${SMPL_API_BASE}/digital_twin/${patientId}`);
        if (twinResponse.ok) {
          const twinData = await twinResponse.json();
          if (twinData.biomarkers) {
            await addBiomarkerOverlays(twinData.biomarkers);
            setStatus(`Loaded ${Object.keys(twinData.biomarkers).length} biomarkers`);
            return;
          }
        }
        
        // Fallback: try agent biomarkers endpoint
        const bioResponse = await fetch(`${SMPL_API_BASE}/agent/patient/${patientId}/biomarkers`);
        if (bioResponse.ok) {
          const bioData = await bioResponse.json();
          if (bioData.status === 'success' && bioData.biomarkers) {
            await addBiomarkerOverlays(bioData.biomarkers);
            setStatus(`Loaded ${Object.keys(bioData.biomarkers).length} biomarkers`);
            return;
          }
        }
        
        // Use sample biomarkers for demo
        const sampleBiomarkers = {
          glucose: 95,
          cholesterol: 180,
          heart_rate: 72,
          hemoglobin: 14.5,
          blood_pressure_systolic: 120,
          oxygen_saturation: 98
        };
        await addBiomarkerOverlays(sampleBiomarkers);
        setStatus('Loaded sample biomarkers (demo)');
        
      } catch (error) {
        console.error('Error loading biomarkers:', error);
        setStatus('Error loading biomarkers');
      }
    }

    async function addBiomarkerOverlays(biomarkers) {
      if (!currentMesh || !biomarkers) return;
      
      // Clear existing overlays
      biomarkerOverlays.forEach(overlay => scene.remove(overlay));
      biomarkerOverlays.clear();
      
      // Create overlays for each biomarker
      Object.entries(biomarkers).forEach(([name, value]) => {
        const position = getBiomarkerPosition(name);
        const status = calculateBiomarkerStatus(name, value);
        const color = getBiomarkerColor(status);
        
        // Create pulsing sphere overlay
        const geometry = new THREE.SphereGeometry(0.08, 16, 16);
        const material = new THREE.MeshPhongMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
          emissive: color,
          emissiveIntensity: 0.3
        });
        
        const overlay = new THREE.Mesh(geometry, material);
        overlay.position.copy(position);
        overlay.userData = {
          biomarker: name,
          value: value,
          status: status,
          pulseSpeed: status === 'normal' ? 1 : 2
        };
        
        scene.add(overlay);
        biomarkerOverlays.set(name, overlay);
        
        // Create floating label
        createBiomarkerLabel(name, value, status, position);
      });
      
      console.log(`âœ… Added ${Object.keys(biomarkers).length} biomarker overlays`);
    }

    function getBiomarkerPosition(biomarkerName) {
      // Map biomarkers to body positions relative to SMPL model
      const positions = {
        'heart_rate': new THREE.Vector3(-0.3, 2.2, 0.4),
        'blood_pressure_systolic': new THREE.Vector3(0.3, 2.2, 0.4),
        'blood_pressure_diastolic': new THREE.Vector3(0.3, 2.0, 0.4),
        'glucose': new THREE.Vector3(0.4, 1.8, 0.3),
        'cholesterol': new THREE.Vector3(-0.4, 1.8, 0.3),
        'hemoglobin': new THREE.Vector3(0, 2.4, 0.5),
        'oxygen_saturation': new THREE.Vector3(0, 2.6, 0.4),
        'temperature': new THREE.Vector3(0, 3.0, 0.2),
        'bmi': new THREE.Vector3(0, 1.5, 0.6)
      };
      
      return positions[biomarkerName] || new THREE.Vector3(0, 2, 0.5);
    }

    function calculateBiomarkerStatus(biomarkerName, value) {
      const ranges = {
        'glucose': [70, 100],
        'cholesterol': [120, 200],
        'hemoglobin': [12, 16],
        'heart_rate': [60, 100],
        'blood_pressure_systolic': [90, 140],
        'blood_pressure_diastolic': [60, 90],
        'oxygen_saturation': [95, 100]
      };
      
      const range = ranges[biomarkerName];
      if (!range) return 'normal';
      
      const [min, max] = range;
      if (value < min) return 'low';
      if (value > max) return 'high';
      if (value > max * 0.9) return 'warning';
      return 'normal';
    }

    function getBiomarkerColor(status) {
      const colors = {
        'normal': 0x00ff00,   // Green
        'warning': 0xffaa00,  // Orange
        'high': 0xff4400,     // Red-orange
        'low': 0x0088ff,      // Blue
        'critical': 0xff0000  // Red
      };
      return colors[status] || 0x00ff00;
    }

    function createBiomarkerLabel(name, value, status, position) {
      // Create text sprite
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      canvas.width = 200;
      canvas.height = 80;
      
      // Background
      context.fillStyle = 'rgba(0, 0, 0, 0.8)';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Text
      context.fillStyle = '#ffffff';
      context.font = 'Bold 16px Arial';
      context.textAlign = 'center';
      
      const displayName = name.replace(/_/g, ' ').toUpperCase();
      context.fillText(displayName, canvas.width / 2, 25);
      context.fillText(`${value}`, canvas.width / 2, 45);
      
      // Status indicator
      const statusColor = status === 'normal' ? '#00ff00' : '#ff4400';
      context.fillStyle = statusColor;
      context.fillText(status.toUpperCase(), canvas.width / 2, 65);
      
      // Create sprite
      const texture = new THREE.CanvasTexture(canvas);
      const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(spriteMaterial);
      
      sprite.position.copy(position);
      sprite.position.y += 0.2;
      sprite.scale.set(0.8, 0.4, 1);
      sprite.userData = { type: 'biomarkerLabel', biomarker: name };
      
      scene.add(sprite);
      biomarkerOverlays.set(`${name}_label`, sprite);
    }

    // Add mouse interaction for biomarker selection
    function setupBiomarkerInteraction() {
      renderer.domElement.addEventListener('click', onBiomarkerClick);
      renderer.domElement.addEventListener('mousemove', onBiomarkerHover);
    }

    function onBiomarkerClick(event) {
      updateMousePosition(event);
      raycaster.setFromCamera(mouse, camera);
      
      const overlayObjects = Array.from(biomarkerOverlays.values());
      const intersects = raycaster.intersectObjects(overlayObjects);
      
      if (intersects.length > 0) {
        const clicked = intersects[0].object;
        if (clicked.userData.biomarker) {
          // Notify parent about biomarker selection
          window.parent.postMessage({
            type: 'biomarkerSelected',
            biomarker: clicked.userData.biomarker,
            value: clicked.userData.value,
            status: clicked.userData.status
          }, '*');
          console.log(`ðŸŽ¯ Selected biomarker: ${clicked.userData.biomarker}`);
        }
      }
    }

    function onBiomarkerHover(event) {
      updateMousePosition(event);
      raycaster.setFromCamera(mouse, camera);
      
      const overlayObjects = Array.from(biomarkerOverlays.values());
      const intersects = raycaster.intersectObjects(overlayObjects);
      
      // Reset cursor
      renderer.domElement.style.cursor = 'default';
      
      if (intersects.length > 0) {
        renderer.domElement.style.cursor = 'pointer';
      }
    }

    function updateMousePosition(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    // Animate biomarker overlays
    function animateBiomarkers() {
      const time = Date.now() * 0.001;
      
      biomarkerOverlays.forEach((overlay, name) => {
        if (overlay.userData.type === 'biomarkerLabel') return;
        
        // Pulsing animation
        const pulseSpeed = overlay.userData.pulseSpeed || 1;
        const pulse = Math.sin(time * pulseSpeed) * 0.2 + 1;
        overlay.scale.setScalar(pulse);
        
        // Gentle floating
        overlay.position.y += Math.sin(time * 0.5 + name.length) * 0.001;
      });
    }

    window.loadSMPLAvatar = async function(patientId, height, weight, gender, opts={}) {
      currentPatientId = patientId;
      if (gender) modelSel.value = gender;
      if (height) heightR.value = heightN.value = height;
      if (weight) weightR.value = weightN.value = weight;
      if (opts.beta1 !== undefined) beta1R.value = beta1N.value = opts.beta1;
      await fetchAndLoad();
      if (patientId) await loadPatientBiomarkers(patientId);
    }
    
    window.updateSMPLParameters = async function(height, weight, gender, opts={}) {
      if (gender) modelSel.value = gender;
      if (height) heightR.value = heightN.value = height;
      if (weight) weightR.value = weightN.value = weight;
      if (opts.beta1 !== undefined) beta1R.value = beta1N.value = opts.beta1;
      await fetchAndLoad();
      if (currentPatientId) await loadPatientBiomarkers(currentPatientId);
    }
    
    window.getSMPLHealth = async function() {
      // Check if GCS assets are accessible
      try {
        const testUrl = `${SMPL_ASSETS_BASE_URL}/male.glb`;
        const response = await fetch(testUrl, { method: 'HEAD' });
        return response.ok ? { status: 'ok', assets_available: true } : { status: 'error', assets_available: false };
      } catch (e) {
        return { status: 'error', assets_available: false, error: e.message };
      }
    }
  </script>
</body>
</html>
